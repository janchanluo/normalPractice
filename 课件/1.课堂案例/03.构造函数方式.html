<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		// 定义构造函数Cat对象
		function Cat(name,color){
		　　　　this.name=name;
		　　　　this.color=color;
		}
		
		
		var cat1 = new Cat("大毛","黄色");
		var cat2 = new Cat("二毛","黑色");
		console.log(cat1)
		console.log(cat1.name); // 大毛
		console.log(cat1.color); // 黄色
		
		// 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。
		console.log(cat1.constructor == Cat); //true
		console.log(cat2.constructor == Cat); //true
		
		
		console.log(cat1 instanceof Cat); //true
		console.log(cat2 instanceof Cat); //true
		
		
		//构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：
		
		function Cat2(name,color){
		　　　　this.name = name;
		　　　　this.color = color;
		　　　　this.type = "猫科动物";
		　　　　this.eat = function(){console.log(123);};
		}
		//Cat2.prototype.eat = function(){console.log(123);};	
		var cat1 = new Cat2("大毛","黄色");
		var cat2 = new Cat2("二毛","黑色");
		//alert(cat1.type); // 猫科动物
		//cat1.eat(); // 吃老鼠
		
		
		//表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。
		//那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，
		//每一次生成一个实例，都必须为重复的内容，多占用一些内存。
		//这样既不环保，也缺乏效率。
		//console.log(cat2.constructor)
		//console.log(cat2.constructor)
		alert(cat1.eat == cat2.eat); //false
		//console.log(cat1.eat)
		//原型主要用来定义方法,构造函数主要用来定义属性
		//构造函数虽然好用，但也并非没有缺点，使用构造函数的最大的问题在于每次
		//创建实例的时候都要重新创建一次方法（理论上每次创建对象的时候对象的
		//属性均不同，而对象的方法是相同的），然而创建两次完全相同的方法是没有
		//必要的，因此，我们可以将函数移到对象外面。

function Blog(name, url) {
    this.name = name;
    this.url = url;
    this.alertUrl = alertUrl;
}

function alertUrl() {
    alert(this.url);
}

var blog = new Blog('wuyuchang', 'http://www.cnblogs.com/wuyuchang/'),
    blog2 = new Blog('cnblogs', 'http://www.cnblogs.com/');
    blog.alertUrl();    // http://www.cnblogs.com/wuyuchang/
    blog2.alertUrl();    // http://www.cnblogs.com/

 　　//我们将alertUrl设置成全局函数，这样一来blog与blog2访问的都是同一个函数，
 //可是问题又来了，在全局作用域中定义了一个实际只想让Blog使用的函数，
 //显示让全局作用域有些名副其实，更让人无法接受的是在全局作用域中定义了
 //许多仅供特定对象使用的方法，浪费空间不说，显然失去了面向对象封装性了，
 //因此可以通过原型来解决此问题。
		
	</script>
</html>
