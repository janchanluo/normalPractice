<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	
	<script type="text/javascript">
		//我们创建的每个函数都有prototype（原型）属性，这个属性是一个指针，
		//指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享
		//的属性和方法。使用原型对象的好处就是可以让所有对象实例共享它所包
		//含的属性及方法。
		function Cat(name,color){
		　　　　this.name = name;
		　　　　this.color = color;
		}
		Cat.prototype.type = "猫科动物";
		Cat.prototype.eat = function(){console.log("吃老鼠")};
				
		var cat1 = new Cat("大毛","黄色");
		var cat2 = new Cat("二毛","黑色");
		console.log(cat1.type); // 猫科动物
		cat1.eat(); // 吃老鼠
		
		console.log(cat1.eat == cat2.eat); //true
		
		
		
		function Student() {}
		Student.name = "中原第一帅！"; 
		Student.age = 20; 
		Student.sayHello = function() {
			console.log("江湖人称" + this.name);
		}
		console.log(Student.name);
		console.log(Student.age); 
		Student.sayHello();
		// 注意name属性是默认自带的。指向这个构造函数的名字
		
		
		// 构造函数升级！ 通过this解决
		function Student2(name, age) { 
		    this.name = name; 
		    this.age = age;
		
		    this.sayHello = function() { 
		        console.log("my name is " + this.name);
		    }
		}
		
		stu = new Student2("中原第一帅！", 18); 
		console.log(stu.name); 
		console.log(stu.age); 
		stu.sayHello();
		
		
		// 原型模式
		function Student3(){
			console.log(this.name)
		};
		Student3.prototype.name = "中原第一帅！"; 
		Student3.prototype.age = 18; 
		Student3.prototype.sayHello = function() {
			console.log("my name is " + this.name);
		}
		var stu = new Student3();
		console.log(stu.name); 
		console.log(stu.age); 
		stu.sayHello();
		
		
		function Student4(name,age){ 
			this.name = name;
			//私有属性
			var age = age;
			this.sayHello=function(){
				console.log("my name is "+this.name+" age "+age);
			}
		}
		var stu = new Student4("中原第一帅！",19); 
		console.log(stu.name);
		//私有属性只能在对象(函数)内部使用
		console.log(stu.age);
		stu.sayHello();
		//原型模式也不是没有缺点，首先，它省略了构造函数传递初始化参数这一环节
		//，结果所有实例在默认情况下都取得了相同的属性值，这样非常不方便，
		//但这还是不是原型的最大问题，原型模式的最大问题在于共享的本性所
		//导致的，由于共享，因此因此一个实例修改了引用，另一个也随之更改了引用。
		//因此我们通常不单独使用原型，而是结合原型模式与构造函数模式。
		
	</script>
</html>
