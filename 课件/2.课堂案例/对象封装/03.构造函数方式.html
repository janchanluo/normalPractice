<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		// 定义构造函数Cat对象
		function Cat(name,color){
		　　　　this.name=name;
		　　　　this.color=color;
		}
		
		
		var cat1 = new Cat("大毛","黄色");
		var cat2 = new Cat("二毛","黑色");
		console.log(cat1)
		console.log(cat1.name); // 大毛
		console.log(cat1.color); // 黄色
		
		// 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。
		console.log(cat1.constructor == Cat); //true
		console.log(cat2.constructor == Cat); //true
		
		
		console.log(cat1 instanceof Cat); //true
		console.log(cat2 instanceof Cat); //true
		
		
		//构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：
		
		function Cat2(name,color){
		　　　　this.name = name;
		　　　　this.color = color;
		　　　　this.type = "猫科动物";
		　　　　this.eat = function(){alert("吃老鼠");};
		}
		
		
		var cat1 = new Cat2("大毛","黄色");
		var cat2 = new Cat2("二毛","黑色");
		alert(cat1.type); // 猫科动物
		cat1.eat(); // 吃老鼠
		
		
		//表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。
		
		alert(cat1.eat == cat2.eat); //false
	</script>
</html>
